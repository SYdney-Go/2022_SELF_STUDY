# 루트노드를 i라고 할 때
# 부모노드의 인덱스는 (i-1)/2
# 자식 노드의 인덱스는 2i+1 2i+2이다.
data = [6, 15, 4, 2, 8, 5, 11, 9, 7, 13]

# 힙의 구현
for i in range(len(data)):
    j = i
    # 말단부터 값을 넣고, 그 다음값을 비교 (첫번째 값부터 넣은 걸로 치고 그 다음 값부터 비교)
    # data[j]와 data[j]의 부모 노드 값과 비교 해서, data[j](자식노드)가 더 작으면 위치를 바꾼다.
    # 반대로 부모노드와 비교해서 자식노드가 더 클 때 위치를 바꿔가면 최대힙이 완성된다.
    # 다음에 data[j]의 j를 변경된 부모노드 위치로 바꿔준다.
    # 그 뒤에 변경된 data[j]의 부모노드와 data[j]를 비교하면서 위의 과정을 반복한다.
    # 그렇게 모든 데이터를 정리 하면 최대힙이 완성된다.
    while (j > 0) and (data[(j-1)//2] < data[j]):
        data[(j-1)//2], data[j] = data[j], data[(j-1)//2]
        j = (j-1) // 2
print(data)

# 힙 정렬 시작
# 최대힙을 가져와서 아래의 방식으로 정리하면 오름차순으로 정렬된다.
for i in range(len(data), 0, -1):
    # 루트노드와 가장 말단의 노드 위치를 변경
    data[i-1], data[0] = data[0], data[i-1]
    j = 0
    # 부모노드를 왼쪽 노드, 오른쪽 노드와 비교했을때 부모 노드가 더 큰 값일때
    # 자식 노드와 부모 노드의 값을 바꾼다.
    # 이때 바꿀때 왼쪽 노드와 오른쪽 노드중 더 작은 값이 있는 곳과 위치를 바꾼다.
    # 부모노드의 위치를 옮겨진 자식 노드의 위치로 갱신한 뒤, 해당 값이 적절한 위치를 찾을 때까지  내려간다. 
    while((2*j+1 < i-1) and (data[j] < data[2*j+1])) or ((2*j+2 < i-1) and (data[j] < data[2*j+2])):
        if (2*j+2 == i-1) or (data[2*j+1] > data[2*j+2]):
            data[j], data[2*j+1] = data[2*j+1], data[j]
            j = 2*j+1
        else:
            data[j], data[2*j+2] = data[2*j+2], data[j]
            j  = 2*j+2
print(data)